# tinyrenderer笔记

## 绘制线段

1. 给出两个点
2. 按照x或y进行像素步进
3. 为了代码简练, 固定从小到大进行步进即可, 因此需要判断起点和终点的位置进行交换
4. 为了防止线段断裂, 需要按照长边方向进行步进
5. 通过两次交换来使得遍历总是按照x来执行, 其中步进方向的设置只要用一个标记使绘制的时侯xy交换回去即可
6. 没有必要在每次步进的时侯都计算一次当前比例坐标t然后再计算短轴坐标, 可以提前计算每次步进的短轴增量然后复用
7. 因为短轴比较短, 因此可以让增量固定为1, 然后计算一个累进误差判断是否需要增加坐标, 每当误差大于0.5时, 向短边方向更新当前的短轴坐标1像素, 然后将累进误差减1
8. 而这个误差值也无需是浮点, 因为这个浮点数仅仅是为了与0.5进行比较. 从斜率的角度考虑, 当短轴的累计比长轴长时, 短轴就应该进行步进了, 因此我们可以用短边的长度\*2作为步进误差, 判断这个误差是否大于长边就可以起到浮点数对比0.5一样的效果, 这样可以省去浮点计算.

## 绘制三角形

1. 边缘显然画线即可, 核心是填充颜色
2. 填充颜色最古老的算法是扫描线法, 核心思路是用平行线以某个轴为方向将三角形内都填上值
3. 扫描线法的核心是找到需要填充的平行线两个端点
4. 简单的方法是将三角形的顶点按y排序, 然后根据y值在中间的点将三角形划分为上下两部分
5. 以y为轴进行遍历, 对每个y值通过插值找到对应两边的x值, 然后对整个线填上颜色
6. 由于三角形被划分为两部分, 因此都可以简单地线性插值得到两段的x
7. 而实际上更常用的三角形填充算法是包围判断法, 这种方法更粗暴但是很适合并行计算
8. 首先对每个三角形计算出对应的包围盒, 然后对盒内的每个像素, 通过重心坐标判断点是否在三角形内(重心坐标全在(0,1)内就代表点在三角形内), 然后对那些点进行着色
9. 给三角形着色的时侯要记得将顶点位置转为整数防止由于精妙的位数差异计算时出现空隙

## Z缓冲

1. 设置Z缓冲的目的是完成深度测试, 替代画家算法复杂的面片划分和BSD排序过程
2. 基本思路就是利用三角形绘制时得到的像素重心坐标, 插值顶点得到各个像素的z值, 然后只保留离相机最近的z值
3. 因此Z缓冲需要光栅化才能进行
4. 得到Z缓冲后渲染的时侯只绘制Z最大(离相机最近)的片元

## 透视投影

1. 透视投影是一种变形, 核心需要用到齐次坐标的仿射变换
2. 齐次坐标仿射变换矩阵很好理解, 就是一个仿射变换矩阵加上一行, 矩阵最后一行默认是0001
3. 矩阵的前三行代表了对目标矩阵(列向量组)对应分量的变换, 最后一列代表位移
4. 当需要处理的向量最后一行为1时, 代表对方是顶点, 需要进行位移, 0的时侯则位移会被忽视
5. 这个过程实际上是将目标量升维进行处理, 处理完一般通过除最后一行的量来进行降维投影
6. 然后变换可以写出级联的变换矩阵, 通常是先将目标移动到旋转点, 然后应用旋转矩阵, 再移回原来的位置, 这样的三矩阵级联结构, 由于矩阵级联的便利性, 这种矩阵可以提前预计算来使用
7. 齐次仿射变换矩阵的最后一行默认是0001, 但是这一行也可以修改, 通常来说是给倒数第二个分量(z)改变值, 这一行代表了要沿什么轴进行成比例的缩放, 中心投影的情况就是[0 0 1-z/c 1]. 
8. 使用这个新矩阵对顶点进行处理后再将顶点的最后一维同除为1, 就能得到投影变形后的顶点位置, 此时再使用正交投影即可绘制出透视投影的效果, 如下图
9. ![picture 1](Media/98d6f60d392299d90899d01fe58c238d999112ec16fa9160ee1e3b9f9b5825f2.png)  

## 相机变换

1. 不记得原理了, 得重看书

## 渲染管线

1. 首先是对各种素材的读取
2. 然后构造模型变换矩阵, 视框矩阵和投影矩阵, 乘在一起
3. 传入顶点着色器, 按照给定的矩阵进行顶点处理, 主要就是负责顶点位置的变换
4. 顶点着色器顺便返回了一些额外信息
5. 然后进行三角形光栅化, 将顶点构成的图元转变为像素(这一步是最慢的), 像素被称为片段, 带有例如重心坐标, 深度值之类的信息
6. 片段传入片段着色器进行着色, 这一步消耗也比较大, 片段着色器常常都比较复杂
7. 片段着色器返回像素颜色和深度, 然后进行深度测试, 只将深度最大的值保存到帧缓存
8. 完成一轮简单的渲染

## 法线贴图

1. 读取法线的时候记得要先进行变换, (X/255)\*2-1
2. 法线需要逆矩阵变换, 注意视图变换不用进入
3. 光源需要顺矩阵变换, 视图变换同样不用进入