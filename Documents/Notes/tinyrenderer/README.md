# tinyrenderer笔记

## 绘制线段

1. 给出两个点
2. 按照x或y进行像素步进
3. 为了代码简练, 固定从小到大进行步进即可, 因此需要判断起点和终点的位置进行交换
4. 为了防止线段断裂, 需要按照长边方向进行步进
5. 通过两次交换来使得遍历总是按照x来执行, 其中步进方向的设置只要用一个标记使绘制的时侯xy交换回去即可
6. 没有必要在每次步进的时侯都计算一次当前比例坐标t然后再计算短轴坐标, 可以提前计算每次步进的短轴增量然后复用
7. 因为短轴比较短, 因此可以让增量固定为1, 然后计算一个累进误差判断是否需要增加坐标, 每当误差大于0.5时, 向短边方向更新当前的短轴坐标1像素, 然后将累进误差减1
8. 而这个误差值也无需是浮点, 因为这个浮点数仅仅是为了与0.5进行比较. 从斜率的角度考虑, 当短轴的累计比长轴长时, 短轴就应该进行步进了, 因此我们可以用短边的长度\*2作为步进误差, 判断这个误差是否大于长边就可以起到浮点数对比0.5一样的效果, 这样可以省去浮点计算.

## 绘制三角形

1. 边缘显然画线即可, 核心是填充颜色
2. 填充颜色最古老的算法是扫描线法, 核心思路是用平行线以某个轴为方向将三角形内都填上值
3. 扫描线法的核心是找到需要填充的平行线两个端点
4. 简单的方法是将三角形的顶点按y排序, 然后根据y值在中间的点将三角形划分为上下两部分
5. 以y为轴进行遍历, 对每个y值通过插值找到对应两边的x值, 然后对整个线填上颜色
6. 由于三角形被划分为两部分, 因此都可以简单地线性插值得到两段的x
7. 而实际上更常用的三角形填充算法是包围判断法, 这种方法更粗暴但是很适合并行计算
8. 首先对每个三角形计算出对应的包围盒, 然后对盒内的每个像素, 通过重心坐标判断点是否在三角形内(重心坐标全在(0,1)内就代表点在三角形内), 然后对那些点进行着色

## Z缓冲

1. 设置Z缓冲的目的是完成深度测试, 替代画家算法复杂的面片划分和BSD排序过程
2. 基本思路就是利用三角形绘制时得到的像素重心坐标, 插值顶点得到各个像素的z值, 然后只保留离相机最近的z值
3. 因此Z缓冲需要光栅化才能进行
4. 得到Z缓冲后渲染的时侯只绘制Z最大(离相机最近)的片元